"""
Script: 06_edge_scores.py
=========================

This script aggregates perâ€‘image scenic scores to the road segment (edge)
level.  It links sample points generated by ``02_densify_roadpoints.py``
with their associated Mapillary images (via ``03_mapillary_metadata.py``)
and the computed features (via ``05_scenic_model.py``).  For each
road segment, it computes the mean scenic score of all sample points
attached to that segment.  The output is a new GeoJSON file of road
segments containing ``scenic_score`` and ``n_samples`` in their
properties.

Usage
-----

    python 06_edge_scores.py --roads data/osm/roads.geojson --samples data/osm/samples.geojson --metadata data/im_meta/mapillary_samples.csv --image-scores data/scores/images.csv --output data/geojson/edges_scored.geojson

Parameters
----------
--roads:
    Path to the original roads GeoJSON file.
--samples:
    Path to the sample points GeoJSON file generated in step 2.
--metadata:
    CSV mapping sample_index to image_id produced in step 3.
--image-scores:
    CSV of image_id and scenic_score produced in step 5.
--output:
    Path where the scored edges will be written as GeoJSON.

Limitations
-----------
This script assumes that ``sample_index`` in the metadata CSV
corresponds to the index of the feature in the samples GeoJSON file.  If
you modify the sampling script or filter points, you must ensure that
this alignment remains valid.
"""

import argparse
import csv
import json
import os
from collections import defaultdict
from pathlib import Path
from typing import Dict, List

from natura.heatmap import iter_heatmap_points, write_heatmap

def load_geojson(path: str) -> dict:
    with open(path, "r", encoding="utf-8") as f:
        return json.load(f)


def load_metadata(csv_path: str) -> List[Dict[str, str]]:
    rows = []
    with open(csv_path, "r", encoding="utf-8") as f:
        reader = csv.DictReader(f)
        for row in reader:
            rows.append(row)
    return rows


def load_image_scores(csv_path: str) -> Dict[str, float]:
    scores = {}
    with open(csv_path, "r", encoding="utf-8") as f:
        reader = csv.DictReader(f)
        for row in reader:
            image_id = row.get("image_id")
            score = row.get("scenic_score")
            if image_id and score is not None:
                try:
                    scores[image_id] = float(score)
                except ValueError:
                    continue
    return scores


def ensure_dir(path: str) -> None:
    directory = os.path.dirname(path)
    if directory and not os.path.exists(directory):
        os.makedirs(directory, exist_ok=True)


def main() -> None:
    parser = argparse.ArgumentParser(description="Aggregate scenic scores to road edges")
    parser.add_argument("--roads", type=str, required=True, help="Roads GeoJSON from step 1")
    parser.add_argument("--samples", type=str, required=True, help="Sample points GeoJSON from step 2")
    parser.add_argument("--metadata", type=str, required=True, help="Metadata CSV from step 3")
    parser.add_argument(
        "--image-scores",
        type=str,
        required=True,
        help="Image scores CSV from step 5 (contains scenic_score)",
    )
    parser.add_argument(
        "--output",
        type=str,
        default="data/geojson/edges_scored.geojson",
        help="Output GeoJSON path",
    )
    parser.add_argument(
        "--heatmap-output",
        type=str,
        default="data/geojson/scenic_heatmap.geojson",
        help="Optional GeoJSON of densified scenic points (used for heatmaps)",
    )
    parser.add_argument(
        "--heatmap-step",
        type=float,
        default=80.0,
        help="Spacing in metres when sampling edges for the heatmap (default: 80)",
    )
    args = parser.parse_args()

    roads = load_geojson(args.roads)
    samples = load_geojson(args.samples).get("features", [])
    metadata_rows = load_metadata(args.metadata)
    image_scores = load_image_scores(args.image_scores)
    # Map from road_id to list of scenic scores
    road_score_lists: Dict[str, List[float]] = defaultdict(list)

    # For each metadata row, find the road_id corresponding to the sample index
    for row in metadata_rows:
        sample_idx_str = row.get("sample_index")
        image_id = row.get("image_id")
        if sample_idx_str is None or image_id is None:
            continue
        try:
            sample_idx = int(sample_idx_str)
        except ValueError:
            continue
        if sample_idx < 0 or sample_idx >= len(samples):
            # Index out of bounds; skip
            continue
        # Lookup scenic score for this image
        score = image_scores.get(image_id)
        if score is None:
            continue
        sample_feat = samples[sample_idx]
        road_id = sample_feat.get("properties", {}).get("road_id")
        if road_id is None:
            continue
        road_score_lists[str(road_id)].append(score)

    # Compute mean scenic score per road
    road_mean_scores: Dict[str, float] = {}
    road_counts: Dict[str, int] = {}
    for rid, scores in road_score_lists.items():
        if scores:
            road_mean_scores[rid] = sum(scores) / len(scores)
            road_counts[rid] = len(scores)

    # Augment roads with scenic_score and n_samples
    for feat in roads.get("features", []):
        road_id = str(feat.get("properties", {}).get("id"))
        if road_id in road_mean_scores:
            feat.setdefault("properties", {})["scenic_score"] = road_mean_scores[road_id]
            feat["properties"]["n_samples"] = road_counts.get(road_id, 0)
        else:
            # If no samples, set null values
            feat.setdefault("properties", {})["scenic_score"] = None
            feat["properties"]["n_samples"] = 0

    ensure_dir(args.output)
    with open(args.output, "w", encoding="utf-8") as f:
        json.dump(roads, f)
    print(f"Wrote scored edges to {args.output}")

    if args.heatmap_output:
        heatmap_points = list(iter_heatmap_points(roads, step_m=args.heatmap_step))
        if heatmap_points:
            write_heatmap(heatmap_points, Path(args.heatmap_output))
            print(f"Heatmap points written to {args.heatmap_output} ({len(heatmap_points)} samples)")
        else:
            print("No scenic scores available to build heatmap.")


if __name__ == "__main__":
    main()
