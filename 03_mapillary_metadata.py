"""
Script: 03_mapillary_metadata.py
================================

This module queries the Mapillary v4 API for imagery metadata near a set of
sample points generated by ``02_densify_roadpoints.py``.  For each point,
the script requests the closest available image and records its ID,
location and compass angle.  The output is a CSV file mapping each
sample point to its matched Mapillary image.

IMPORTANT: This script requires an active internet connection and a valid
Mapillary API access token.  Without a token, the API will return
401/403 errors and no data will be collected.  See
https://www.mapillary.com/developer/api-documentation/ for details on
obtaining a token.

Usage
-----

    python 03_mapillary_metadata.py \
        --input data/osm/samples.geojson \
        --token YOUR_MAPILLARY_ACCESS_TOKEN \
        --output data/im_meta/mapillary_samples.csv

Parameters
----------
--input:
    Path to the GeoJSON file of sample points.
--token:
    Your Mapillary access token.  It can also be provided via the
    environment variable ``MAPILLARY_TOKEN``.
--limit:
    Maximum number of images to fetch.  Useful for testing or rate
    limiting.  Defaults to unlimited (fetch for all samples).
--output:
    Path to write the CSV containing the matched metadata.  The CSV
    includes columns: ``sample_index``, ``sample_lat``, ``sample_lon``,
    ``image_id``, ``image_lat``, ``image_lon``, ``compass_angle``.

Notes
-----
This script intentionally avoids complicated dependencies such as
geopandas.  It uses the standard ``requests`` library to call the API
and writes a simple CSV using the builtâ€‘in ``csv`` module.  The
Mapillary API may return no result for some sample points if there are
no nearby images; those samples will be skipped.
"""

import argparse
import csv
import json
import os
import sys
from typing import Dict, List, Optional

import requests

MAPILLARY_ENDPOINT = "https://graph.mapillary.com/images"


def load_samples(path: str) -> List[Dict[str, float]]:
    """Load sample points from a GeoJSON file.

    Each feature in the GeoJSON should be a point with ``coordinates``
    [lon, lat].  Returns a list of dictionaries containing ``lat`` and
    ``lon`` for each sample.
    """
    with open(path, "r", encoding="utf-8") as f:
        data = json.load(f)
    samples = []
    for feature in data.get("features", []):
        geom = feature.get("geometry", {})
        if geom.get("type") != "Point":
            continue
        coords = geom.get("coordinates", [])
        if len(coords) != 2:
            continue
        lon, lat = coords
        samples.append({"lat": lat, "lon": lon})
    return samples


def query_mapillary(lat: float, lon: float, token: str) -> Optional[Dict[str, float]]:
    """Query Mapillary API for the closest image to the given point.

    Returns a dictionary with keys ``id``, ``lat``, ``lon`` and
    ``compass_angle`` if an image is found, or ``None`` if no images
    exist nearby.
    """
    params = {
        "fields": "id,geometry,compass_angle",
        "closeto": f"{lon},{lat}",
        "limit": 1,
        "access_token": token,
    }
    try:
        resp = requests.get(MAPILLARY_ENDPOINT, params=params)
    except Exception as exc:
        print(f"Request error for point ({lat}, {lon}): {exc}", file=sys.stderr)
        return None
    if resp.status_code != 200:
        print(
            f"Mapillary API error {resp.status_code} for point ({lat}, {lon}): {resp.text}",
            file=sys.stderr,
        )
        return None
    data = resp.json()
    if "data" not in data or not data["data"]:
        return None
    item = data["data"][0]
    image_id = item.get("id")
    # The geometry is a GeoJSON point geometry with coordinates [lon, lat]
    geometry = item.get("geometry", {})
    coords = geometry.get("coordinates", [None, None])
    if not image_id or coords[0] is None:
        return None
    return {
        "id": image_id,
        "lat": coords[1],
        "lon": coords[0],
        "compass_angle": item.get("compass_angle"),
    }


def ensure_dir(path: str) -> None:
    directory = os.path.dirname(path)
    if directory and not os.path.exists(directory):
        os.makedirs(directory, exist_ok=True)


def main() -> None:
    parser = argparse.ArgumentParser(description="Query Mapillary metadata for sample points")
    parser.add_argument("--input", type=str, required=True, help="Input sample points GeoJSON file")
    parser.add_argument(
        "--token",
        type=str,
        default=os.environ.get("MAPILLARY_TOKEN"),
        help="Mapillary API access token (or set MAPILLARY_TOKEN env var)",
    )
    parser.add_argument(
        "--limit",
        type=int,
        default=None,
        help="Maximum number of points to process (useful for testing)",
    )
    parser.add_argument(
        "--output",
        type=str,
        default="data/im_meta/mapillary_samples.csv",
        help="Output CSV file path",
    )
    args = parser.parse_args()

    if not args.token:
        raise SystemExit("A Mapillary access token is required. Provide via --token or MAPILLARY_TOKEN env var.")

    samples = load_samples(args.input)
    total = len(samples)
    print(f"Loaded {total} sample points from {args.input}")
    limit = args.limit if args.limit is not None else total

    ensure_dir(args.output)
    with open(args.output, "w", newline="", encoding="utf-8") as csvfile:
        fieldnames = [
            "sample_index",
            "sample_lat",
            "sample_lon",
            "image_id",
            "image_lat",
            "image_lon",
            "compass_angle",
        ]
        writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
        writer.writeheader()

        for idx, sample in enumerate(samples[:limit]):
            lat, lon = sample["lat"], sample["lon"]
            meta = query_mapillary(lat, lon, args.token)
            if not meta:
                continue
            row = {
                "sample_index": idx,
                "sample_lat": lat,
                "sample_lon": lon,
                "image_id": meta["id"],
                "image_lat": meta["lat"],
                "image_lon": meta["lon"],
                "compass_angle": meta.get("compass_angle"),
            }
            writer.writerow(row)
            if (idx + 1) % 50 == 0:
                print(f"Processed {idx + 1}/{limit} samples")
    print(f"Metadata written to {args.output}")


if __name__ == "__main__":
    main()