"""
Script: 03_mapillary_metadata.py
================================

This module queries the Mapillary v4 API for imagery metadata near a set of
sample points generated by ``02_densify_roadpoints.py``. For each point,
the script requests the closest available image and records its ID,
location and compass angle. The output is a CSV file mapping each
sample point to its matched Mapillary image.

IMPORTANT: Requires internet access and a valid Mapillary API access token.
Set via --token or the MAPILLARY_TOKEN env var.

Usage
-----
    # PowerShell-friendly (avoid quoting issues with |):
    $env:MAPILLARY_TOKEN='MLY|...'
    python 03_mapillary_metadata.py --input data/osm/samples.geojson --limit 100 --radius 300 --output data/im_meta/mapillary_samples.csv

Parameters
----------
--input:
    Path to the GeoJSON file of sample points.
--token:
    Your Mapillary access token. May also be provided via MAPILLARY_TOKEN.
--limit:
    Maximum number of points to process (for testing). Defaults to all.
--radius:
    Approximate search radius in metres for building a bbox around each point.
    Defaults to 300 m.
--output:
    Output CSV path with columns: sample_index, sample_lat, sample_lon,
    image_id, image_lat, image_lon, compass_angle, image_distance_m.
--verbose:
    Print extra debug info when a point returns no candidates or requests fail.

Notes
-----
- Uses Mapillary Graph API v4 with Authorization header (OAuth token).
- Uses a bbox query + client-side nearest selection (more reliable than closeto+radius).
"""

import argparse
import csv
import json
import math
import os
import sys
from pathlib import Path
from typing import Dict, List, Optional, TypedDict

import requests
from natura.cache import DiskCache

MAPILLARY_ENDPOINT = "https://graph.mapillary.com/images"


class Sample(TypedDict):
    index: int
    lat: float
    lon: float


def load_samples(path: str) -> List[Sample]:
    """Load sample points from a GeoJSON file, preserving feature order."""
    with open(path, "r", encoding="utf-8") as f:
        data = json.load(f)
    samples: List[Sample] = []
    for idx, feature in enumerate(data.get("features", [])):
        geom = feature.get("geometry", {})
        if geom.get("type") != "Point":
            continue
        coords = geom.get("coordinates", [])
        if len(coords) < 2:
            continue
        lon, lat = coords[:2]
        samples.append({"index": idx, "lat": lat, "lon": lon})
    return samples


def make_session(token: str) -> requests.Session:
    """Create a requests session with the Mapillary OAuth header."""
    s = requests.Session()
    s.headers.update({
        "Authorization": f"OAuth {token}",
        "User-Agent": "natura-scenic-mvp/0.1",
        "Accept": "application/json",
    })
    return s


def meters_to_bbox(lat: float, lon: float, radius_m: float):
    """Return (minLon, minLat, maxLon, maxLat) bbox ~radius_m around (lat,lon)."""
    # Simple equirectangular-ish conversion; good enough for small radii
    dlat = radius_m / 111_320.0
    dlon = radius_m / (111_320.0 * max(0.0001, math.cos(math.radians(lat))))
    return (lon - dlon, lat - dlat, lon + dlon, lat + dlat)


def haversine_m(a_lat: float, a_lon: float, b_lat: float, b_lon: float) -> float:
    R = 6371000.0
    dlat = math.radians(b_lat - a_lat)
    dlon = math.radians(b_lon - a_lon)
    la1 = math.radians(a_lat)
    la2 = math.radians(b_lat)
    h = math.sin(dlat / 2) ** 2 + math.cos(la1) * math.cos(la2) * math.sin(dlon / 2) ** 2
    return 2 * R * math.asin(math.sqrt(h))


def query_mapillary(sess: requests.Session, lat: float, lon: float, radius: int, verbose: bool = False) -> Optional[Dict[str, float]]:
    """
    Query Mapillary API for images inside a small bbox around (lat,lon),
    then pick the nearest image client-side. Returns None if none found.
    """
    minlon, minlat, maxlon, maxlat = meters_to_bbox(lat, lon, radius)
    params = {
        "fields": "id,geometry,compass_angle,captured_at",
        "bbox": f"{minlon},{minlat},{maxlon},{maxlat}",
        "limit": 50  # pull several candidates; we select nearest
    }
    try:
        resp = sess.get(MAPILLARY_ENDPOINT, params=params, timeout=20)
        resp.raise_for_status()
    except requests.RequestException as exc:
        if verbose:
            print(f"[WARN] Mapillary request failed at ({lat:.6f},{lon:.6f}): {exc}", file=sys.stderr)
        return None

    data = resp.json()
    items = data.get("data") or []
    if not items:
        if verbose:
            print(f"[INFO] No images in bbox for ({lat:.6f},{lon:.6f}) radius~{radius}m", file=sys.stderr)
        return None

    best = None
    best_d = float("inf")
    for it in items:
        geom = (it.get("geometry") or {})
        coords = geom.get("coordinates") or []
        if len(coords) < 2:
            continue
        ilon, ilat = float(coords[0]), float(coords[1])
        d = haversine_m(lat, lon, ilat, ilon)
        if d < best_d:
            best_d = d
            best = it

    if not best:
        return None

    coords = best["geometry"]["coordinates"]
    return {
        "id": best.get("id"),
        "lat": float(coords[1]),
        "lon": float(coords[0]),
        "compass_angle": best.get("compass_angle"),
        "distance_m": best_d,
    }


def ensure_dir(path: str) -> None:
    directory = os.path.dirname(path)
    if directory and not os.path.exists(directory):
        os.makedirs(directory, exist_ok=True)


def print_progress(completed: int, total: int) -> None:
    """Render a simple in-place progress bar for terminal users."""
    if total <= 0:
        return
    percent = (completed / total) * 100
    bar_width = 30
    filled = int(bar_width * completed / total)
    bar = "#" * filled + "-" * (bar_width - filled)
    sys.stdout.write(f"\rProgress: [{bar}] {percent:6.2f}% ({completed}/{total})")
    sys.stdout.flush()
    if completed >= total:
        sys.stdout.write("\n")
        sys.stdout.flush()


def main() -> None:
    parser = argparse.ArgumentParser(description="Query Mapillary metadata for sample points")
    parser.add_argument("--input", type=str, required=True, help="Input sample points GeoJSON file")
    parser.add_argument(
        "--token",
        type=str,
        default=os.environ.get("MAPILLARY_TOKEN"),
        help="Mapillary API access token (or set MAPILLARY_TOKEN env var)",
    )
    parser.add_argument(
        "--limit",
        type=int,
        default=None,
        help="Maximum number of points to process (useful for testing)",
    )
    parser.add_argument(
        "--radius",
        type=int,
        default=300,
        help="Search radius (m) used to build a bbox around each point (default: 300)",
    )
    parser.add_argument(
        "--output",
        type=str,
        default="data/im_meta/mapillary_samples.csv",
        help="Output CSV file path",
    )
    parser.add_argument(
        "--verbose",
        action="store_true",
        help="Print extra debugging info for missing results / request errors",
    )
    parser.add_argument(
        "--cache-dir",
        type=str,
        default="data/cache",
        help="Directory for metadata cache (per sample point)",
    )
    parser.add_argument(
        "--cache-ttl",
        type=float,
        default=14 * 24 * 3600,
        help="Cache expiry in seconds (default: 14 days). Set to 0 for no expiry.",
    )
    parser.add_argument(
        "--no-cache",
        action="store_true",
        help="Disable caching Mapillary metadata requests",
    )
    args = parser.parse_args()

    # Resolve token (PowerShell-safe if set as env var)
    token = args.token or os.environ.get("MAPILLARY_TOKEN")
    if not token:
        raise SystemExit("A Mapillary access token is required. Provide via --token or MAPILLARY_TOKEN env var.")

    samples = load_samples(args.input)
    total = len(samples)
    print(f"Loaded {total} sample points from {args.input}")

    limit = args.limit if args.limit is not None else total
    samples_to_process = samples[:limit]
    num_samples = len(samples_to_process)

    fieldnames = [
        "sample_index",
        "sample_lat",
        "sample_lon",
        "image_id",
        "image_lat",
        "image_lon",
        "compass_angle",
        "image_distance_m",
    ]

    ensure_dir(args.output)

    if num_samples == 0:
        with open(args.output, "w", newline="", encoding="utf-8") as csvfile:
            writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
            writer.writeheader()
        print(f"No samples to process; wrote header to {args.output}")
        return

    sess = make_session(token)
    progress_enabled = sys.stdout.isatty()
    progress_step = max(1, num_samples // 20)
    matches = 0

    cache: Optional[DiskCache] = None
    if not args.no_cache:
        ttl = args.cache_ttl if args.cache_ttl > 0 else None
        cache = DiskCache(Path(args.cache_dir), namespace="mapillary_metadata", max_age=ttl)

    with open(args.output, "w", newline="", encoding="utf-8") as csvfile:
        writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
        writer.writeheader()

        for processed, sample in enumerate(samples_to_process, start=1):
            lat, lon = sample["lat"], sample["lon"]
            cache_key = None
            cached_entry = None
            if cache is not None:
                cache_key = DiskCache.key_from_mapping(
                    {
                        "lat": round(lat, 6),
                        "lon": round(lon, 6),
                        "radius": args.radius,
                    }
                )
                cached_entry = cache.load(cache_key)

            if cached_entry is not None:
                meta = (cached_entry or {}).get("value")
            else:
                meta = query_mapillary(sess, lat, lon, args.radius, verbose=args.verbose)
                if cache is not None and cache_key is not None:
                    cache.save(cache_key, {"value": meta})
            if meta:
                matches += 1
            row = {
                "sample_index": sample["index"],
                "sample_lat": lat,
                "sample_lon": lon,
                "image_id": (meta or {}).get("id", ""),
                "image_lat": (meta or {}).get("lat", ""),
                "image_lon": (meta or {}).get("lon", ""),
                "compass_angle": (meta or {}).get("compass_angle", ""),
                "image_distance_m": (meta or {}).get("distance_m", ""),
            }
            writer.writerow(row)
            if progress_enabled:
                print_progress(processed, num_samples)
            elif processed % progress_step == 0 or processed == num_samples:
                print(f"Processed {processed}/{num_samples} samples")

    print(f"Metadata written to {args.output}; matched {matches} images out of {num_samples} samples")


if __name__ == "__main__":
    main()
